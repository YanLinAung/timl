(define impl (fn)
  (if fn
    (or (get timl#lambdas (string fn))
        (try
          (let ((output     (capture (:silent "verbose function" (f:join (list fn)))))
                (raw        (f:split output "\n"))
                (file       (f:expand (f:matchstr (second raw) "\\S\\+$")))
                (definition (first raw))
                (name       ((compose symbol timl#demunge) (f:matchstr definition " \\zs\\S\\+\\ze(")))
                (arglist    (map (compose symbol timl#demunge) (f:split (f:matchstr definition "(\\zs.*\\ze)") ", "))))
            (filter (compose not nil? last) (dict "name" name "arglist" arglist "file" file)))
          (catch 123 e (dict))))))

(define source (fn)
  (if-let (impl (impl fn))
    (list 'lambda
          (get impl "arglist" '...)
          (get impl "form" '...))))

(define special-forms
  '(if begin let lambda define
     quote quasiquote unquote unquote-splicing function
     try catch finally))

(define-syntax doc (sym)
  (let ((topic (if (<= 0 (f:index special-forms sym))
                 (string "vim-" sym))))
    `(begin
       (throw (string "timl#repl: exit help " (or ,topic (f:substitute (string ,sym) "^\\w\\+\\zs$" "(" ""))))
       (throw "timl#repl: exit"))))

(define-syntax help (sym) (doc sym))
