(ns timl.repl)

(defn qf
  ([] (qf *e))
  ([e]
   (#*setqflist (. e qflist))
   (throw "timl#repl: exit copen")))

(defn breakpoint-fn [env]
  (let [str (#*input (format "%s=>> " (ns-name *ns*)))]
    (when (#*len str)
      (newline)
      (try
        (prn (#*timl#loader#eval (read-string str) (ns-name *ns*) env))
        (catch "" e (set! *e e) (println (:exception e))))
      (recur env))))

(defmacro breakpoint []
  `(timl.repl/breakpoint-fn ~(list #*eval "locals")))

(defmacro breakadd []
  `(execute "execute 'breakadd func '.(1+expand('<slnum>')).' '.matchstr(expand('<sfile>'), '.*\\.\\zs.*')"))
(defn breakme []
  (breakadd)
  (+ 1 (* 2 3)))

(defn compile [body]
  (print (. (#*timl#compiler#build body) body)))

(defmacro doc [sym]
  (let [topic (if (special-symbol? sym)
                (str "timl-" sym)
                (resolve sym))]
    `(do
       (throw (str "timl#repl: exit help " (or ~topic (str '~sym)))))))

(defmacro edit [sym]
  `(let [m (meta (var ~sym))]
     (if (not= (:file m "NO_SOURCE_PATH") "NO_SOURCE_PATH")
       (throw (str "timl#repl: exit edit +" (:line m) " " (#*fnameescape (:file m)))))))
