(define (impl fn)
  (if fn
    (or (f:get timl#lambdas (string fn) nil)
        (try
          (let ((output     (capture (: "silent verbose function" (f:join (list fn)))))
                (raw        (f:split output "\n"))
                (file       (f:expand (f:matchstr (second raw) "\\S\\+$")))
                (definition (first raw))
                (name       ((comp symbol timl#demunge) (f:matchstr definition " \\zs\\S\\+\\ze(")))
                (arglist    (map (comp symbol timl#demunge) (f:split (f:matchstr definition "(\\zs.*\\ze)") ", "))))
            (filter (comp not nil? last) (dict "name" name "arglist" arglist "file" file)))
          (catch 123 e (dict))))))

(define (source fn)
  (if-let (impl (impl fn))
    (list 'lambda
          (get impl :arglist '...)
          (get impl :form '...))))

(define special-forms
  '[if begin let lambda define :
     quote quasiquote unquote unquote-splicing function
     try catch finally])

(define-syntax (doc sym)
  (let ((topic (if (<= 0 (f:index special-forms sym))
                 (string "timl-" sym))))
    `(begin
       (throw (string "timl#repl: exit help " (or ,topic (f:substitute (string ,sym) "^\\w\\+\\zs$" "(" ""))))
       (throw "timl#repl: exit"))))
