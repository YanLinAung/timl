(defn impl [fn]
  (if fn
    (or (f:get timl#lambdas (str fn) nil)
        (try
          (let [output     (capture (: "silent verbose function" (f:join [fn])))
                raw        (f:split output "\n")
                file       (f:expand (f:matchstr (second raw) "\\S\\+$"))
                definition (first raw)
                name       ((comp symbol timl#demunge) (f:matchstr definition " \\zs\\S\\+\\ze("))
                arglist    (map (comp symbol timl#demunge) (f:split (f:matchstr definition "(\\zs.*\\ze)") ", "))]
            (filter (comp not nil? last) (dict "name" name "arglist" arglist "file" file)))
          (catch 123 e (dict))))))

(defn source [fn]
  (if-let (impl (impl fn))
    (list 'fn
          (get impl :arglist '...)
          (get impl :form '...))))

(def special-forms
  '[if begin let fn define :
     quote syntax-quote unquote unquote-splicing function
     try catch finally])

(defmacro doc [sym]
  (let [topic (if (<= 0 (f:index special-forms sym))
                (str "timl-" sym))]
    `(do
       (throw (str "timl#repl: exit help " (or ~topic (f:substitute (str ~sym) "^\\w\\+\\zs$" "(" ""))))
       (throw "timl#repl: exit"))))
