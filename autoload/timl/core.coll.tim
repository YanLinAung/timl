(in-ns 'timl#core)

(defn not-empty [xs] (if (empty? xs) nil xs))
(defn next [xs] (not-empty (rest xs)))
(defn second [xs] (first (rest xs)))
(defn last [xs] (if (next xs) (recur (next xs)) (first xs)))
(defn conj [xs ...] (append xs ...))
(defn butlast [s]
  (loop ((ret '()) (s s))
    (if (next s)
      (recur (conj ret (first s)) (next s))
      ret)))

(defn reverse [xs] (f:reverse (f:copy xs)))

(defn sorter [>]
  (lambda (x y)
    (if (> x y)
      1
      (if (> y x)
        -1
        0))))

(defn sort [xs ...]
  (if ...
    (f:sort (f:copy xs) (sorter (first ...)) {})
    (f:sort (f:copy xs))))

(defn reductions [f init xs]
  (cons init (if xs
    (reductions f (f init (first xs)) (rest xs)))))

(defn get-in [m ks] (reduce get m ks))
(defn filter [f coll] (reduce (lambda (m o) (if (f o) (append m (list o)) m)) '() coll))
