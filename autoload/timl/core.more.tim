(in-ns 'timl#core)
(define define-syntax (...)
  `(let ((fn# (define ,@...)))
     (f:extend (get timl#lambdas (string fn#)) (dict "macro" 1))
     fn#))
(set! ((f:get g:timl#lambdas "timl#core#define_syntax") "macro") 1)

#_(define-syntax ns (n)
    (list
      'begin
      (if (not (f:exists (string "g:" (timl#munge (string n "#" "*uses*")))))
        `(set! ,(f:timl#symbol (string n "#*uses*")) (list 'timl#core)))
      `(in-ns ',n)))

(define pr-str (...) (f:join (map timl#pr-str ...)))
(define pr (...) (echo (apply pr-str ...)))

(define constantly (x) (lambda (...) x))
(define partial (f ...)
  (let ((args ...))
    (lambda (...) (apply f (append args ...)))))
(define comp (f ...)
  (if-let (fns ...)
    (lambda (...) (f (apply (apply compose fns) ...)))
    f))

(define-syntax loop (bindings ...)
 `((lambda ,(map first bindings) ,@...) ,@(map last bindings)))
(define 1+ (partial + 1))
(define 1- (n) (- n 1))
(define reverse (xs) (f:reverse (f:copy xs)))
(define not (x) (if x 0 1))
(define second (xs) (get xs 1 nil))
(define last (xs) (get xs -1 nil))
(define butlast (xs) (sublist xs 0 -2))
(define get-in (m ks) (reduce get m ks))

(define read-string (string) (timl#reader#read-string string))
(define eval (form) (timl#eval form))

(define sorter (>)
  (lambda (x y)
    (if (> x y)
      1
      (if (> y x)
        -1
        0))))

(define sort (xs ...)
  (if ...
    (f:sort (f:copy xs) (sorter (first ...)) {})
    (f:sort (f:copy xs))))

(define reductions (f init xs)
  (cons init (if xs
    (reductions f (f init (first xs)) (rest xs)))))

(define-syntax or (x ...)
  (if ...
    `(let ((or# ,x)) (if or# or# (or ,@...)))
    x))

(define-syntax and (x ...)
  (if ...
    `(let ((and# ,x)) (if and# (and ,@...) and#))
    x))

(define-syntax when (test ...)
  `(if ,test (begin ,@...)))

(define-syntax if-let (binding then ...)
  (let ((form (first binding))
        (tst (last binding)))
    `(let ((temp# ,tst))
      (if temp#
        (let ((,form temp#)) ,then) ,@...))))

(define-syntax cond (...)
  (when ...
    (list 'if (first (first ...))
          (second (first ...))
          (cons `cond (rest ...)))))

(define-syntax -> (x ...)
  (if ...
    (let ((form (first ...))
          (more (rest ...)))
      (if more
        `(-> (-> ,x ,form) ,@more)
        (if (list? form)
          `(,(first form) ,x ,@(rest form))
          (list form x))))
    x))

(define-syntax capture (...)
  `(begin
     (try
       (: "redir => g:timl_core_captured")
       ,@...
       (finally (: "redir END")))
     (f:substitute g:timl_core_captured "^\n" "" "")))

(define-syntax include-guard (var)
  (let ((str (timl#munge (string var))))
   `(if (f:exists ,str)
     (: 'finish)
     (set! ,var 1))))

(define build-option-string (...)
  (sublist
    (loop ((s "")
           (x (first ...))
           (more (rest ...)))
      (if (nil? x)
        s
        (recur
          (if (symbol? x) (string s " " x) (string s (f:fnameescape (string x))))
          (first more) (rest more))
        )) 1 -1))

(define extract-option-names (...)
  (map (lambda (x) (f:matchstr (string x) "\\%(inv\\|no\\)\\=\\zs\\w\\+")) (filter symbol? ...)))

(define extract-option-restore (...)
  (if-let (options (apply extract-option-names ...))
    (string "setlocal " (f:join options "< ") "<")))

(define-syntax setlocal (...)
  `(: (string "setlocal " ,(apply build-option-string ...))))

(define-syntax setglobal (...)
  `(: (string "setlocal " ,(apply build-option-string ...))))
