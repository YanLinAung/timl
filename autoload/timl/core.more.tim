(in-ns 'timl#core)
(defmacro ns (ns)
  (list
    'do
    (if (not (f:exists (string "g:" (timl#munge (string ns "#" "*uses*")))))
      `(setq ,(f:timl#symbol (string ns "#*uses*")) (list 'timl#core)))
    `(in-ns ',ns)))

(defmacro loop (bindings ...)
 `((lambda ,(map first bindings) ,@...) ,@(map last bindings)))
(defun pr-str (...) (f:join (map timl#pr-str ...)))
(defun pr (...) (print (apply pr-str ...)))
(defun 1+ (n) (+ n 1))
(defun 1- (n) (- n 1))
(defun constantly (x) (lambda (...) x))
(defun reverse (xs) (f:reverse (f:copy xs)))
(defun not (x) (if x 0 1))
(defun second (xs) (get xs 1 nil))
(defun last (xs) (get xs -1 nil))
(defun butlast (xs) (sublist xs 0 -2))
(defun get-in (m ks) (reduce get m ks))
(defun apply (f x ...)
  (let ((args (append (list x) ...)))
    (f:call f (append (butlast args) (last args)) {})))

(defun sorter (>)
  (lambda (x y)
    (if (> x y)
      1
      (if (> y x)
        -1
        0))))

(defun sort (xs ...)
  (if ...
    (f:sort (f:copy xs) (sorter (first ...)) {})
    (f:sort (f:copy xs))))

(defun reductions (f init xs)
  (cons init (if xs
    (reductions f (f init (first xs)) (rest xs)))))

(defmacro or (x ...)
  (if ...
    `(let ((or# ,x)) (if or# or# (or ,@...)))
    x))

(defmacro and (x ...)
  (if ...
    `(let ((and# ,x)) (if and# (and ,@...) and#))
    x))

(defmacro when (test ...)
  `(if ,test (do ,@...)))

(defmacro if-let (binding then ...)
  (let ((form (first binding))
        (tst (last binding)))
    `(let ((temp# ,tst))
      (if temp#
        (let ((,form temp#)) ,then) ,@...))))

(defmacro -> (x ...)
  (if ...
    (let ((form (first ...))
          (more (rest ...)))
      (if more
        `(-> (-> ,x ,form) ,@more)
        (if (list? form)
          `(,(first form) ,x ,@(rest form))
          (list form x))))
    x))

(defmacro capture (...)
  `(do
     (try
       (:redir "=> g:timl_core_captured")
       ,@...
       (finally (:redir "END")))
     (f:substitute g:timl_core_captured "^\n" "" "")))
