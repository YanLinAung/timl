(in-ns 'timl#core)

(define pr-str (...) (f:join (map timl#printer#string ...)))
(define pr (...) (echo (apply pr-str ...)))
(define read-string (string) (timl#reader#read-string string))
(define eval (form) (timl#eval form))

(define constantly (x) (lambda (...) x))
(define partial (f ...)
  (let ((args ...))
    (lambda (...) (apply f (append args ...)))))
(define comp (f ...)
  (if-let (fns ...)
    (lambda (...) (f (apply (apply comp fns) ...)))
    f))

(define true (not nil))
(define false (not true))

(define 1+ (partial + 1))
(define 1- (n) (- n 1))
(define zero? (partial equal? 0))
(define nonzero? (comp not zero?))

(define-syntax capture (...)
  `(begin
     (try
       (: "redir => g:timl_core_captured")
       ,@...
       (finally (: "redir END")))
     (f:substitute g:timl_core_captured "^\n" "" "")))

(define-syntax include-guard (var)
  (let ((str (timl#munge (string var))))
   `(if (f:exists ,str)
     (: 'finish)
     (set! ,var 1))))

(define build-option-string (args)
  (sublist
    (loop ((s "")
           (x (first args))
           (more (rest args)))
      (if (nil? x)
        s
        (recur
          (if (symbol? x) (string s " " x) (string s (f:fnameescape (string x))))
          (first more) (rest more))
        )) 1 -1))

(define extract-option-names (args)
  (map (lambda (x) (f:matchstr (string x) "\\%(inv\\|no\\)\\=\\zs\\w\\+")) (filter symbol? args)))

(define extract-option-restore (args)
  (if-let (options (extract-option-names args))
    (string "setlocal " (f:join (map string options) "< ") "<")))

(define-syntax setlocal (...)
  `(: (string "setlocal " ,(build-option-string args))))

(define-syntax setglobal (...)
  `(: (string "setlocal " ,(build-option-string args))))
