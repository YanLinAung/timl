(in-ns 'timl#core)

(def (defmacro name ...)
  `(let* [fn# (def ~name (fn* ~name ~@...))]
     (f:extend (f:get timl#lambdas (str fn#)) (dict "macro" 1))
     fn#))
(set! (. (f:get g:timl#lambdas "timl#core#defmacro") macro) 1)

(defmacro fn [...] `(fn* ~@...))
(defmacro let [...] `(let* ~@...))

(defmacro defn [name params ...]
  `(def ~name (fn ~name ~params ~@...)))

(defmacro declare [...]
  `(do ~@(map (fn [n] (list 'def n)) ...)))

(defmacro loop [flat ...]
  (let [bindings (partition 2 flat)]
    `((fn ~(map first bindings) ~@...) ~@(map (fn [x] (first (rest x))) bindings))))

(defmacro or [x ...]
  (if ...
    `(let [or# ~x] (if or# or# (or ~@...)))
    x))

(defmacro and [x ...]
  (if ...
    `(let [and# ~x] (if and# (and ~@...) and#))
    x))

(defmacro when [test ...]
  `(if ~test (do ~@...)))

(defmacro if-let [binding then ...]
  (let [form (first binding)
        tst (first (rest binding))]
    `(let [temp# ~tst]
      (if temp#
        (let [~form temp#] ~then) ~@...))))

(defmacro cond [...]
  (when ...
    (list 'if (first (first ...))
          (first (rest (first ...)))
          (cons `cond (rest ...)))))

(defmacro -> [x ...]
  (if ...
    (let [form (first ...)
          more (rest ...)]
      (if more
        `(-> (-> ~x ~form) ~@more)
        (if (list? form)
          `(~(first form) ~x ~@(rest form))
          (list form x))))
    x))
