(in-ns 'timl.core)

(def defmacro (fn* defmacro [name & fdecl]
  `(let* [fn# (def ~name (fn* ~name ~@fdecl))]
     (set! (. fn# macro) 1)
     fn#)))
(set! (. defmacro macro) 1)

(defmacro fn [& args] `(fn* ~@args))
(defmacro let [& args] `(let* ~@args))

(defmacro defn [name params & fdecl]
  `(def ~name (fn ~name ~params ~@fdecl)))

(defmacro declare [& names]
  `(do ~@(map (fn [n] (list 'def n)) names)))

(defmacro loop [flat & body]
  (let [bindings (partition 2 flat)]
    `((fn ~(map first bindings) ~@body) ~@(map (fn [x] (first (rest x))) bindings))))

(defmacro ns [name]
  `(do
     (in-ns '~name)
     (refer 'timl.core)))

(defmacro or
  ([] nil)
  ([x] x)
  ([x & xs] `(let [or# ~x] (if or# or# (or ~@xs)))))

(defmacro and
  ([] true)
  ([x] x)
  ([x & xs] `(let [and# ~x] (if and# (and ~@xs) and#))))

(defmacro when [test & body]
  `(if ~test (do ~@body)))

(defmacro if-let [bindings then & else]
  (let [form (first bindings)
        tst (first (rest bindings))]
    `(let [temp# ~tst]
      (if temp#
        (let [~form temp#] ~then) ~@else))))

(defmacro when-let [bindings & body]
  (let [form (first bindings)
        tst (first (rest bindings))]
    `(let [temp# ~tst]
      (if temp#
        (let [~form temp#] ~@body)))))


(defmacro cond [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (first (rest clauses))
          (cons `cond (rest (rest clauses))))))

(defmacro -> [x & forms]
  (if (seq forms)
    (let [form (first forms)
          more (rest forms)] (if more `(-> (-> ~x ~form) ~@more) (if (list? form)
          `(~(first form) ~x ~@(rest form))
          (list form x))))
    x))

(defmacro binding [bindings & body]
  (if (seq bindings)
    `(let [old# ~(first bindings)]
       (try
         (set! ~(first bindings) ~(first (rest bindings)))
         (binding ~(vec (rest (rest bindings))) ~@body)
         (finally (set! ~(first bindings) old#))))
    `(do ~@body)))

; does not nest
(defmacro with-out-str [& body]
  `(do
     (try
       (set! l:TimLfn (fn [] ~@body))
       (: "redraw")
       (: "redir => l:TimLcaptured")
       (: "silent call timl#call(l:TimLfn, [])")
       (finally (: "unlet! l:TimLfn") (: "redir END")))
     (#*substitute l:TimLcaptured "^\n" "" "g")))
