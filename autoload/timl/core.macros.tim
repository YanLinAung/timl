(in-ns 'timl.core)

(defmacro cond [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (first (rest clauses))
          (cons `cond (rest (rest clauses))))))

(defmacro -> [x & forms]
  (if (seq forms)
    (let [form (first forms)
          more (rest forms)] (if more `(-> (-> ~x ~form) ~@more) (if (list? form)
          `(~(first form) ~x ~@(rest form))
          (list form x))))
    x))

(defmacro binding [bindings & body]
  (if (seq bindings)
    `(let [old# ~(first bindings)]
       (try
         (set! ~(first bindings) ~(first (rest bindings)))
         (binding ~(vec (rest (rest bindings))) ~@body)
         (finally (set! ~(first bindings) old#))))
    `(do ~@body)))

; does not nest
(defmacro with-out-str [& body]
  `(do
     (try
       (set! l:TimLfn (fn [] ~@body))
       (: "redraw")
       (: "redir => l:TimLcaptured")
       (: "silent call timl#call(l:TimLfn, [])")
       (finally (: "unlet! l:TimLfn") (: "redir END")))
     (#*substitute l:TimLcaptured "^\n" "" "g")))

(defmacro time [& body]
  `(let [reltime# (#*reltime)
        result# (do ~@body)]
     (printf "Elapsed time: %s secs\n" (#*reltimestr (#*reltime reltime#)))
     result#))
