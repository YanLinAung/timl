(defun inc (n) (+ n 1))
(defun dec (n) (- n 1))
(defun constantly (x) (lambda (...) x))
(defun reverse (xs) (f:reverse (f:copy xs)))
(defun first (x) (car x))
(defun rest (x) (car x))
(defun not (x) (if x 0 1))
(defun last (xs) (first (reverse xs)))
(defun butlast (xs) (sublist xs 0 -2))
(defun apply (f x ...)
  (let (args (append (list x) ...))
    (f:call f (append (butlast args) (last args)) {})))

(define-macro or (x y) `(let (or# ,x) (if or# or# ,y)))
