(defun pr (x) (:echo (schim#pr-str x)))
(defun inc (n) (+ n 1))
(defun dec (n) (- n 1))
(defun constantly (x) (lambda (...) x))
(defun reverse (xs) (f:reverse (f:copy xs)))
(defun not (x) (if x 0 1))
(defun last (xs) (get xs -1 nil))
(defun butlast (xs) (sublist xs 0 -2))
(defun apply (f x ...)
  (let (args (append (list x) ...))
    (f:call f (append (butlast args) (last args)) {})))

(defmacro or (x ...)
  (if ...
    `(let (or# ,x) (if or# or# (or ,@...)))
    x))

(defmacro and (x ...)
  (if ...
    `(let (and# ,x) (if and# (and ,@...) and#))
    x))

(defmacro when (test ...)
  `(if ,test (begin ,@...)))

(defmacro if-let (binding ...)
  (let (form (first binding)
         tst (last binding))
    `(let (temp# ,tst)
      (if temp#
        (let (,form temp#) ,@...)))))
